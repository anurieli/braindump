{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup project environment and configuration",
        "description": "Configure environment variables, Supabase client, OpenAI client, and basic project structure",
        "details": "Create .env.example file with required variables (DATABASE_URL, NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY, OPENAI_API_KEY). Set up Supabase client configuration in lib/supabase.ts. Configure OpenAI client in lib/openai.ts. Create folder structure: lib/, components/, store/, types/, config/. Update next.config.js for any necessary configurations.",
        "testStrategy": "Verify environment variables load correctly, test Supabase and OpenAI client connections, ensure folder structure is created",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create .env.example file with required variables",
            "description": "Define all necessary environment variables for the project in a .env.example file to serve as a template for local development and CI/CD environments.",
            "dependencies": [],
            "details": "Create a file named `.env.example` in the project root. Add the following keys with placeholder values: DATABASE_URL, NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY, OPENAI_API_KEY.",
            "status": "pending",
            "testStrategy": "Verify that after creating a local `.env` file from the example, the Next.js application can access these variables via `process.env` on the server side."
          },
          {
            "id": 2,
            "title": "Set up Supabase client configuration",
            "description": "Create and configure the Supabase client to enable interaction with the Supabase backend for database, authentication, and other services.",
            "dependencies": [
              1
            ],
            "details": "Create a file at `lib/supabase.ts`. Import `createClient` from `@supabase/supabase-js` and export a new client instance initialized with the `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_ANON_KEY` variables.",
            "status": "pending",
            "testStrategy": "Create a test API route or server component that uses the client to perform a simple query (e.g., fetch from a non-existent table) and logs the result or error to confirm connectivity."
          },
          {
            "id": 3,
            "title": "Configure OpenAI client",
            "description": "Initialize the OpenAI client to enable interaction with the OpenAI API for features like generating text summaries or embeddings.",
            "dependencies": [
              1
            ],
            "details": "Create a file at `lib/openai.ts`. Import the `OpenAI` class from the `openai` package. Export an instantiated client using the `OPENAI_API_KEY` from the environment variables.",
            "status": "pending",
            "testStrategy": "Create a test script or a temporary API route that uses the configured client to make a simple, low-cost API call, such as `openai.models.list()`, to verify successful authentication."
          },
          {
            "id": 4,
            "title": "Create project folder structure and update next.config.js",
            "description": "Establish the foundational directory structure for organizing code and assets, and update the Next.js configuration for any project-specific needs.",
            "dependencies": [],
            "details": "Create the following empty directories in the project's root or `src/` folder: `lib/`, `components/`, `store/`, `types/`, `config/`. Review `next.config.js` for any required initial configurations.",
            "status": "pending",
            "testStrategy": "Verify that all specified folders have been created in the correct location. Run the development server (`npm run dev`) to ensure the application starts without errors from `next.config.js`."
          }
        ]
      },
      {
        "id": 2,
        "title": "Create database schema and migrations",
        "description": "Set up PostgreSQL database tables with proper indexes and constraints for brain dumps, ideas, edges, and attachments",
        "details": "Create Supabase migrations for: brain_dumps table (id, name, created_at, viewport_x, viewport_y, viewport_zoom), ideas table (id, brain_dump_id, text, summary, position_x, position_y, state, embeddings vector), edges table (id, brain_dump_id, parent_id, child_id, type, note), edge_types table (id, name, is_default), attachments table (id, idea_id, type, url, filename, metadata). Enable pgvector extension. Add proper indexes and foreign key constraints.",
        "testStrategy": "Run migrations successfully, verify table structure, test basic CRUD operations, validate constraints work",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Enable pgvector extension in Supabase",
            "description": "Create a Supabase migration to enable the 'pgvector' extension, which is required for storing and querying vector embeddings.",
            "dependencies": [],
            "details": "Create a new migration file in the Supabase project. Add the SQL statement 'CREATE EXTENSION IF NOT EXISTS vector;' to this file to enable the vector data type and its associated functions.",
            "status": "pending",
            "testStrategy": "Run the Supabase migration and verify the extension is successfully enabled by checking the 'Database -> Extensions' section in the Supabase dashboard or by running '\\dx' in the SQL editor."
          },
          {
            "id": 2,
            "title": "Create 'brain_dumps' table migration",
            "description": "Create the migration for the 'brain_dumps' table, which acts as the main container for a set of ideas and stores its canvas viewport state.",
            "dependencies": [],
            "details": "Define the 'brain_dumps' table with the following columns: id (UUID, primary key), name (text), created_at (timestamptz with default now()), viewport_x (float8), viewport_y (float8), and viewport_zoom (float8).",
            "status": "pending",
            "testStrategy": "Run the migration and inspect the table structure in the Supabase table editor to ensure all columns, data types, and default values are correctly configured."
          },
          {
            "id": 3,
            "title": "Create 'ideas' table migration with vector column",
            "description": "Create the migration for the 'ideas' table to store individual notes, including their content, position on the canvas, and vector embeddings for semantic search.",
            "dependencies": [
              1,
              2
            ],
            "details": "Define the 'ideas' table with columns: id (UUID, PK), brain_dump_id (UUID, FK to brain_dumps), text (text), summary (text, nullable), position_x (float8), position_y (float8), state (text), and embeddings (vector).",
            "status": "pending",
            "testStrategy": "After running the migration, verify the table schema, paying close attention to the 'vector' column type. Test inserting a sample row with a valid brain_dump_id to ensure the basic structure works."
          },
          {
            "id": 4,
            "title": "Create 'edge_types' and 'edges' tables migration",
            "description": "Create migrations for the 'edge_types' lookup table and the 'edges' table, which defines the directional relationships between different ideas.",
            "dependencies": [
              3
            ],
            "details": "Create 'edge_types' table (id, name, is_default). Create 'edges' table (id, brain_dump_id, parent_id, child_id, type, note). The parent_id and child_id columns will be foreign keys referencing the 'ideas' table.",
            "status": "pending",
            "testStrategy": "Run the migrations and verify both table schemas. Attempt to insert a new edge connecting two existing idea records to validate the relationship structure."
          },
          {
            "id": 5,
            "title": "Create 'attachments' table migration",
            "description": "Create the migration for the 'attachments' table to store metadata about external resources like files or URLs that are linked to specific ideas.",
            "dependencies": [
              3
            ],
            "details": "Define the 'attachments' table with columns: id (UUID, PK), idea_id (UUID, FK to ideas), type (text), url (text), filename (text, nullable), and metadata (jsonb).",
            "status": "pending",
            "testStrategy": "Run the migration and verify the table schema is correct, especially the 'jsonb' type for the metadata column. Test by inserting a sample attachment record linked to an existing idea."
          },
          {
            "id": 6,
            "title": "Add all foreign key constraints and performance indexes",
            "description": "Create a final migration to add all necessary foreign key constraints to enforce relational integrity and create indexes to optimize query performance.",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Add foreign key constraints for: ideas.brain_dump_id, edges.brain_dump_id, edges.parent_id, edges.child_id, edges.type, and attachments.idea_id. Create indexes on all foreign key columns and an HNSW index on ideas.embeddings.",
            "status": "pending",
            "testStrategy": "Run the migration and confirm all constraints and indexes are active via the Supabase dashboard. Test data integrity by attempting to insert an edge with a non-existent idea_id, which should fail."
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement Zustand store architecture",
        "description": "Create global state management for brain dumps, ideas, edges, and UI state using Zustand",
        "details": "Create store/index.ts with slices for: brainDumpsSlice (current brain dump, list, viewport state), ideasSlice (ideas array, CRUD operations), edgesSlice (edges array, CRUD operations), uiSlice (theme, grid settings, modals). Implement optimistic updates, undo/redo functionality with action history. Include selectors for computed values like visible ideas based on viewport.",
        "testStrategy": "Test state updates, verify optimistic UI works, test undo/redo functionality, ensure proper state isolation between brain dumps",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up Base Zustand Store and Slice Structure",
            "description": "Initialize the main Zustand store file (`store/index.ts`) and define the overall state shape. Set up the pattern for combining multiple state slices.",
            "dependencies": [],
            "details": "Create the main `useStore` hook using Zustand's `create` function. Establish the structure for combining `brainDumpsSlice`, `ideasSlice`, `edgesSlice`, and `uiSlice` into a single, cohesive global state object.",
            "status": "pending",
            "testStrategy": "Verify that the `useStore` hook can be imported and used within a React component without errors. Check that the initial state of the combined store matches the expected default values from each slice placeholder."
          },
          {
            "id": 2,
            "title": "Implement brainDumpsSlice for Workspace and Viewport State",
            "description": "Create the state and actions for managing the list of brain dumps, the currently active one, and the canvas viewport state (pan, zoom).",
            "dependencies": [
              1
            ],
            "details": "In `store/slices/brainDumpsSlice.ts`, define state for `brainDumps` (list), `currentBrainDumpId`, and `viewport`. Implement actions to load dumps, switch the current dump, and update viewport transform.",
            "status": "pending",
            "testStrategy": "Test actions for loading and switching brain dumps. Simulate user interaction to pan and zoom, verifying that the viewport state in the store updates accordingly. Test selectors for retrieving the current dump."
          },
          {
            "id": 3,
            "title": "Implement ideasSlice with Full CRUD Operations",
            "description": "Build the state and actions for managing ideas within a brain dump, including create, read, update, and delete (CRUD) functionalities.",
            "dependencies": [
              1
            ],
            "details": "In `store/slices/ideasSlice.ts`, define state to hold a collection of ideas (e.g., an object map with IDs as keys). Implement `addIdea`, `updateIdeaContent`, `updateIdeaPosition`, and `deleteIdea` actions.",
            "status": "pending",
            "testStrategy": "Write unit tests for each CRUD action. Test adding an idea and confirming its presence. Update an idea's text and position and verify the changes. Delete an idea and ensure it's removed from the state."
          },
          {
            "id": 4,
            "title": "Implement edgesSlice for Relationship Management",
            "description": "Create the state and actions for managing the edges that connect ideas, including creation, updates, and deletion.",
            "dependencies": [
              1,
              3
            ],
            "details": "In `store/slices/edgesSlice.ts`, define state for a collection of edges. Implement `addEdge`, `updateEdge`, and `deleteEdge` actions. An edge should contain `source` and `target` idea IDs.",
            "status": "pending",
            "testStrategy": "Test creating an edge between two mock ideas. Test updating edge properties (e.g., type). Test deleting an edge. Implement and test logic that automatically deletes edges connected to a deleted idea."
          },
          {
            "id": 5,
            "title": "Implement uiSlice for Global App and UI State",
            "description": "Create the state and actions for managing global UI elements such as theme settings, grid visibility, and the state of modals.",
            "dependencies": [
              1
            ],
            "details": "In `store/slices/uiSlice.ts`, define state properties for `theme` ('light'/'dark'), `isGridVisible` (boolean), and `activeModal` (e.g., 'settings', null). Implement actions like `toggleTheme`, `setGridVisibility`, `openModal`, and `closeModal`.",
            "status": "pending",
            "testStrategy": "Test actions for toggling the theme and grid visibility, verifying the state changes. Test the flow of opening and closing a modal by checking the value of `activeModal` in the store."
          },
          {
            "id": 6,
            "title": "Implement Optimistic Updates for a Responsive UI",
            "description": "Refactor CRUD actions in the `ideasSlice` and `edgesSlice` to implement optimistic updates, providing immediate UI feedback before API confirmation.",
            "dependencies": [
              3,
              4
            ],
            "details": "Modify `addIdea`, `deleteIdea`, `addEdge`, etc., to update the Zustand state immediately. These actions will then trigger an async API call. Include logic to revert the state change if the API call fails.",
            "status": "pending",
            "testStrategy": "Using a mocked API, test the success case: an action updates the UI instantly and the state persists. Test the failure case: an action updates the UI instantly, the API mock returns an error, and the UI reverts to its previous state."
          },
          {
            "id": 7,
            "title": "Add Undo/Redo Functionality with State History",
            "description": "Integrate a temporal middleware into the Zustand store to track a history of state changes and enable undo and redo actions for the user.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Use the `zustand/middleware/temporal` middleware to wrap the state slices that require history tracking (ideas, edges, etc.). Expose the `undo` and `redo` functions from the temporal store to the UI. Configure the middleware to ignore transient state like UI slice changes.",
            "status": "pending",
            "testStrategy": "Perform a sequence of actions (e.g., add idea, move idea, delete idea). Call the `undo` action and verify the state reverts correctly. Then, call the `redo` action and verify the state is restored. Confirm that UI state (like theme) is not affected by undo/redo."
          }
        ]
      },
      {
        "id": 4,
        "title": "Build core canvas system with Konva",
        "description": "Implement infinite 2D canvas with pan, zoom, grid, and viewport management using react-konva",
        "details": "Create components/Canvas.tsx with Konva Stage and Layer. Implement pan (Ctrl+drag), zoom (Cmd+scroll), grid rendering (dots/lines), viewport culling for performance. Add keyboard shortcuts (Ctrl+0 for reset). Implement smooth animations and 60 FPS performance. Save viewport state to store and persist to database every 5 seconds.",
        "testStrategy": "Test smooth pan/zoom at 60 FPS, verify viewport culling with 500+ items, test keyboard shortcuts, validate viewport state persistence",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Basic Konva Stage and Layer",
            "description": "Create the main canvas component and initialize the Konva Stage and a primary Layer to serve as the foundation for all other canvas features.",
            "dependencies": [],
            "details": "Create the file `components/Canvas.tsx`. This component will render a `Konva.Stage` and a single `Konva.Layer`. The stage should be configured to fill the available screen space.",
            "status": "pending",
            "testStrategy": "Verify that the canvas component renders without errors and a blank stage is visible on the screen."
          },
          {
            "id": 2,
            "title": "Implement Pan Functionality",
            "description": "Enable users to pan across the infinite canvas by holding the Ctrl key and dragging the mouse.",
            "dependencies": [
              1
            ],
            "details": "In `Canvas.tsx`, make the stage draggable. Use event listeners for `mousedown`, `mousemove`, and `mouseup` combined with a check for the `Ctrl` key to enable/disable panning. Update the stage's x and y position accordingly.",
            "status": "pending",
            "testStrategy": "Hold Ctrl and drag the mouse. The canvas view should move smoothly. Releasing Ctrl should stop the panning behavior even if the mouse is still being dragged."
          },
          {
            "id": 3,
            "title": "Implement Zoom Functionality",
            "description": "Allow users to zoom in and out of the canvas using the mouse scroll wheel while holding the Cmd/Ctrl key.",
            "dependencies": [
              1
            ],
            "details": "Add an `onWheel` event handler to the Konva Stage. When the event fires with the Cmd (or Ctrl for non-Mac) key pressed, calculate the new scale and position to implement zooming towards the mouse pointer. Update the stage's scale and position.",
            "status": "pending",
            "testStrategy": "Hold Cmd/Ctrl and scroll the mouse wheel. The canvas should zoom in and out, centered on the cursor's position. Verify that zoom limits are reasonable."
          },
          {
            "id": 4,
            "title": "Add Dynamic Grid Rendering",
            "description": "Render a background grid of dots or lines that updates dynamically with pan and zoom operations to provide spatial context.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create a separate `Grid` component or layer. On every viewport change (pan/zoom), recalculate and redraw the grid lines/dots. The grid density should change at different zoom levels for clarity and performance.",
            "status": "pending",
            "testStrategy": "Pan and zoom the canvas. The grid should always be visible and adapt its appearance correctly to the current zoom level and position."
          },
          {
            "id": 5,
            "title": "Implement Viewport Culling",
            "description": "Optimize rendering performance by only drawing the canvas objects that are currently within the visible viewport.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Before rendering objects on the main layer, calculate the current viewport boundaries based on the stage's position and scale. Filter the list of objects (e.g., ideas) to only include those whose bounding boxes intersect with the viewport.",
            "status": "pending",
            "testStrategy": "Add 500+ items to the canvas, some inside and many outside the initial view. Pan around and verify that performance remains at or near 60 FPS and that objects appear/disappear correctly at the viewport edges."
          },
          {
            "id": 6,
            "title": "Implement Keyboard Shortcuts",
            "description": "Add keyboard shortcuts for common canvas actions, starting with resetting the view.",
            "dependencies": [
              2,
              3
            ],
            "details": "Add a global keyboard event listener. Implement the `Ctrl+0` shortcut to reset the canvas view by setting the stage's position to (0, 0) and scale to 1. Ensure the event listener does not interfere with text inputs.",
            "status": "pending",
            "testStrategy": "Pan and zoom away from the origin. Press `Ctrl+0`. The canvas view should immediately reset to the default position and zoom level."
          },
          {
            "id": 7,
            "title": "Implement Smooth Animations for Navigation",
            "description": "Ensure all user-initiated navigation changes, like zooming and shortcut-triggered view resets, are smoothly animated instead of being instantaneous.",
            "dependencies": [
              3,
              6
            ],
            "details": "Use `Konva.Tween` to animate changes to the stage's scale and position properties. Refactor the zoom and view reset logic to use tweens with a short duration (e.g., 200ms) and an easing function for a fluid user experience.",
            "status": "pending",
            "testStrategy": "Zoom with the scroll wheel and use the `Ctrl+0` reset shortcut. Verify that the transitions are animated smoothly rather than jumping instantly."
          },
          {
            "id": 8,
            "title": "Implement Viewport State Persistence",
            "description": "Save the current viewport state (position and zoom) to the Zustand store and persist it to the database periodically.",
            "dependencies": [
              2,
              3
            ],
            "details": "On stage 'dragend' and 'wheel' events, update the viewport state in the Zustand store. Use a debounced function or a `setInterval` to trigger an API call every 5 seconds, persisting the viewport state from the store to the `brain_dumps` table in the database.",
            "status": "pending",
            "testStrategy": "Pan and zoom the canvas, then refresh the page. The canvas should load with the last saved position and zoom level. Check the network tab and database to confirm the state is being saved."
          }
        ]
      },
      {
        "id": 5,
        "title": "Create idea components and interaction system",
        "description": "Implement idea rendering, hover states, drag interactions, and modal system",
        "details": "Create components/Idea.tsx with three view states: compact (summary/truncated), peak (hover with full text), modal (double-click). Implement drag-to-move with position updates, drag-onto-other for edge creation. Add hover effects, parent indicators (gold stroke), loading states. Create IdeaModal component with full text, attachments, edit mode, connected ideas display.",
        "testStrategy": "Test all view states, verify drag interactions work smoothly, test modal functionality, validate hover effects and state transitions",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Basic Idea Component with Compact and Peak Views",
            "description": "Develop the fundamental 'Idea.tsx' component using react-konva. This component will handle rendering the 'compact' (summary) view and the 'peak' (full text on hover) view, including the transition between them.",
            "dependencies": [],
            "details": "Create the file at 'components/Idea.tsx'. The component should accept idea data as props and render a Konva Group containing a Rect for the background and a Text element. Implement 'onMouseEnter' and 'onMouseLeave' to toggle between a truncated summary and the full text.",
            "status": "pending",
            "testStrategy": "Render the component on a Konva stage. Verify it displays the compact view by default. On hover, confirm it expands to the peak view showing full text, and reverts back on mouse leave."
          },
          {
            "id": 2,
            "title": "Implement Drag-to-Move Functionality for Ideas",
            "description": "Enable users to move ideas around the canvas by dragging them. The component's new position must be captured and persisted.",
            "dependencies": [
              1
            ],
            "details": "In 'Idea.tsx', set the 'draggable' prop on the main Konva Group. Use the 'onDragEnd' event handler to get the new x and y coordinates. Dispatch an action to update the idea's position in the global state and trigger a database update.",
            "status": "pending",
            "testStrategy": "Drag an idea to a new position on the canvas. Verify the UI updates immediately. Refresh the application and confirm the idea loads in its new, persisted position."
          },
          {
            "id": 3,
            "title": "Implement Drag-onto-Other Interaction for Edge Creation",
            "description": "Develop the interaction where dragging one idea and dropping it onto another creates a directional edge (link) between them.",
            "dependencies": [
              2
            ],
            "details": "This requires advanced event handling. While dragging an idea, we need to detect which other idea component it is currently hovering over. On 'onDragEnd' or 'onDrop', check for a valid drop target. If one exists, call an API route or service function to create a new record in the 'edges' table, linking the dragged idea (parent) to the target idea (child).",
            "status": "pending",
            "testStrategy": "Drag one idea component and drop it directly onto another. Verify that a new edge is created in the database and a visual line is rendered on the canvas connecting the two ideas."
          },
          {
            "id": 4,
            "title": "Create the IdeaModal Component and Double-Click Interaction",
            "description": "Build the 'IdeaModal.tsx' component that provides a detailed view of an idea. This modal should be triggered by double-clicking an idea on the canvas.",
            "dependencies": [
              1
            ],
            "details": "Create a new React component for the modal UI outside of the Konva canvas. Add an 'onDblClick' event handler to the Idea component that sets the active idea in a global state, triggering the modal to open. The modal will display the full text, attachments, and connected ideas.",
            "status": "pending",
            "testStrategy": "Double-click on an idea component. Verify a modal window opens and displays the correct, full details for that idea. Test closing the modal."
          },
          {
            "id": 5,
            "title": "Implement Edit Mode within the Idea Modal",
            "description": "Add functionality to the IdeaModal that allows the user to switch to an 'edit mode', modify the idea's text, and save the changes.",
            "dependencies": [
              4
            ],
            "details": "Within 'IdeaModal.tsx', add a button to toggle an 'isEditing' state. When true, replace the text display with a textarea input. Add a 'Save' button that triggers an API call to update the idea's text in the database and then exits edit mode.",
            "status": "pending",
            "testStrategy": "Open the modal, enter edit mode, change the idea's text, and click save. Verify the text is updated in the modal, on the canvas component, and persists after a page refresh."
          },
          {
            "id": 6,
            "title": "Add Parent Indicators and Loading State Visual Feedback",
            "description": "Enhance the Idea component with visual cues, including a gold stroke for ideas that are parents in a relationship and a loading indicator for asynchronous operations.",
            "dependencies": [
              1,
              3
            ],
            "details": "Conditionally render a 'Rect' with a gold stroke within the Idea component's Konva Group if the idea's data indicates it is a parent. Also, manage a 'loading' state within the component and display a visual indicator (e.g., a spinner or opacity change) during data fetching or saving.",
            "status": "pending",
            "testStrategy": "Create a relationship between two ideas. Confirm the parent idea now has a gold stroke. Trigger an update and verify a loading state is briefly visible."
          },
          {
            "id": 7,
            "title": "Integrate Idea Positioning with Canvas Pan and Zoom",
            "description": "Ensure that the absolute positioning of ideas correctly interacts with the canvas's viewport state (pan/zoom), so they scale and move correctly with the canvas.",
            "dependencies": [
              2
            ],
            "details": "This subtask focuses on integrating the idea's world coordinates (stored in the DB) with the 'react-konva' Stage's scale and position. No new code might be needed if Konva is set up correctly, but this involves verifying that the coordinates from 'onDragEnd' are world coordinates and that they render correctly as the user pans and zooms the canvas.",
            "status": "pending",
            "testStrategy": "Place several ideas on the canvas. Pan and zoom the canvas in and out extensively. Verify all ideas maintain their relative positions and scale correctly with the viewport."
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement quick input system with AI processing",
        "description": "Build idea creation input with attachment support and background AI summarization",
        "details": "Create components/QuickInput.tsx with text input, attachment drag-drop zone, file upload handling. Implement idea creation flow: immediate optimistic UI, background grammar cleaning, OpenAI summarization (GPT-4), embedding generation (text-embedding-3-small). Add retry logic, error handling, batch processing for embeddings. Support file types: images, PDFs, text files, URLs with metadata fetching.",
        "testStrategy": "Test rapid idea creation (10 in 30 seconds), verify AI processing works asynchronously, test file upload and URL metadata, validate error handling",
        "priority": "high",
        "dependencies": [
          3,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Basic QuickInput Component UI",
            "description": "Develop the fundamental UI structure for the quick input system, including a text area for idea entry and a submit button.",
            "dependencies": [],
            "details": "Create the file `components/QuickInput.tsx`. This component will manage its own internal state for the text input. The initial version will just capture text.",
            "status": "pending",
            "testStrategy": "Verify that the text area accepts input and the component renders correctly. Manual testing is sufficient for this initial UI component."
          },
          {
            "id": 2,
            "title": "Add File Drag-and-Drop Zone to QuickInput",
            "description": "Enhance the QuickInput component by adding a user interface element that allows users to drag and drop files for attachment.",
            "dependencies": [
              1
            ],
            "details": "Integrate a library like `react-dropzone` into `QuickInput.tsx`. Style the dropzone to provide visual feedback on hover and when files are dropped.",
            "status": "pending",
            "testStrategy": "Test by dragging various file types onto the zone. Verify UI changes on hover and after a file is dropped. Check that the file list is displayed."
          },
          {
            "id": 3,
            "title": "Implement File Upload Handling and API Integration",
            "description": "Develop the logic to handle file uploads from the client to the server, using Supabase Storage for persistence.",
            "dependencies": [
              2
            ],
            "details": "Create a client-side function to take files from the dropzone, and an API endpoint (e.g., `app/api/attachments`) to receive and upload them to Supabase Storage. This depends on Task 9 for the API route.",
            "status": "pending",
            "testStrategy": "Upload a test file and verify it appears in the Supabase Storage bucket. Test API endpoint for correct responses and error handling on failed uploads."
          },
          {
            "id": 4,
            "title": "Set Up Background AI Summarization and Grammar Cleaning",
            "description": "Integrate with the OpenAI API to process the text from new ideas for summarization and grammar correction using GPT-4.",
            "dependencies": [
              1
            ],
            "details": "Create a background job or serverless function that is triggered on idea creation. This function will call the OpenAI GPT-4 API to generate a summary and clean up the grammar of the input text.",
            "status": "pending",
            "testStrategy": "Provide various text inputs and verify that the output from the AI process is a concise summary and has improved grammar. Check API call logs for success."
          },
          {
            "id": 5,
            "title": "Implement Embedding Generation with OpenAI",
            "description": "Generate vector embeddings for each new idea's text content using the OpenAI `text-embedding-3-small` model for future similarity searches.",
            "dependencies": [
              1
            ],
            "details": "Extend the background processing job to also call the OpenAI Embeddings API. Implement batch processing to efficiently handle multiple new ideas. Store the resulting vector in the `ideas` table (requires Task 2 schema).",
            "status": "pending",
            "testStrategy": "Create an idea and inspect the database to confirm a vector embedding has been generated and stored in the `embeddings` column. Verify the vector dimensions."
          },
          {
            "id": 6,
            "title": "Implement Optimistic UI Updates for Idea Creation",
            "description": "Ensure a fast user experience by immediately adding new ideas to the UI before backend processing is complete.",
            "dependencies": [
              1
            ],
            "details": "When a user submits an idea, immediately call an action in the Zustand store (from Task 3) to add a temporary version of the idea to the `ideas` slice. Update this temporary item with final data once the backend processing completes.",
            "status": "pending",
            "testStrategy": "Rapidly create several ideas and observe that they appear on the canvas instantly. Verify that they are later updated with AI-generated data (like summaries) without disrupting the UI."
          },
          {
            "id": 7,
            "title": "Add Retry Logic and Error Handling for AI and File Processing",
            "description": "Build robust error handling and automated retry mechanisms for all asynchronous background operations, such as file uploads and OpenAI API calls.",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Wrap API calls for file uploads, summarization, and embeddings in a utility function that includes exponential backoff retry logic. Implement UI feedback to notify the user if an operation permanently fails after several retries.",
            "status": "pending",
            "testStrategy": "Simulate API failures (e.g., using incorrect API keys or network blocking) and verify that the retry logic is triggered. Confirm that permanent failures are gracefully handled and communicated to the user."
          },
          {
            "id": 8,
            "title": "Support Multiple File Types and URL Metadata Fetching",
            "description": "Extend file handling to support images, PDFs, and text files. Add functionality to parse URLs and fetch their metadata.",
            "dependencies": [
              3
            ],
            "details": "On the server, when a URL is attached, use a library like `unfurl.js` or `metascraper` to fetch its title, description, and preview image. For file uploads, store the file type and relevant metadata in the `attachments` table.",
            "status": "pending",
            "testStrategy": "Attach a URL and verify that the correct metadata is fetched and associated with the idea. Upload an image, a PDF, and a .txt file and confirm they are handled correctly."
          }
        ]
      },
      {
        "id": 7,
        "title": "Build edge creation and management system",
        "description": "Implement drag-to-connect functionality, edge types, and relationship visualization",
        "details": "Create components/Edge.tsx for line rendering with direction indicators. Implement edge creation modal with type selection (6 defaults + custom). Add edge constraints validation (no cycles, max 1 parent). Create EdgeTypeManager for custom types. Implement hover effects, click-to-delete, double-click for notes. Add visual feedback during drag operations.",
        "testStrategy": "Test edge creation flow, verify constraint validation, test custom edge types, validate visual rendering and interactions",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Edge Component for Visual Line Rendering",
            "description": "Develop the base React component to visually represent an edge as a line between two points, including a direction indicator.",
            "dependencies": [],
            "details": "Create the `components/Edge.tsx` file. This component will take start and end coordinates as props and render an SVG line between them. It must include an arrowhead or similar marker to indicate the direction of the relationship.",
            "status": "pending",
            "testStrategy": "Unit test the component by providing various start and end coordinates. Visually verify in Storybook or a test environment that the line and direction indicator render correctly in all positions."
          },
          {
            "id": 2,
            "title": "Implement Drag-to-Connect Functionality",
            "description": "Implement the core user interaction for creating edges by dragging from a source idea node to a target idea node, with visual feedback during the drag.",
            "dependencies": [
              1
            ],
            "details": "Modify the `Idea` component to have a drag handle. On drag, use the `Edge` component to render a temporary line from the source node to the mouse cursor. On drop over another `Idea` component, trigger the edge creation flow.",
            "status": "pending",
            "testStrategy": "Manually test dragging from one idea to another. Verify the preview line appears and follows the cursor. Confirm that dropping on a valid target proceeds to the next step, while dropping on the background cancels the action."
          },
          {
            "id": 3,
            "title": "Develop Edge Creation Modal with Type Selection",
            "description": "Build the modal dialog that appears after a successful drag-to-connect action, allowing the user to select the relationship type.",
            "dependencies": [
              2
            ],
            "details": "Create `components/EdgeCreationModal.tsx`. This modal will be triggered after the drag-to-connect is completed. It should display a dropdown list with the 6 default edge types. User selection will be passed to the next stage.",
            "status": "pending",
            "testStrategy": "Trigger the modal by successfully connecting two nodes. Verify that the modal appears and contains the default list of edge types. Test selecting a type and confirming."
          },
          {
            "id": 4,
            "title": "Add Edge Constraint Validation for Cycles and Max Parent",
            "description": "Implement the logic to prevent the creation of edges that violate graph constraints, specifically preventing cyclical dependencies and nodes having more than one parent.",
            "dependencies": [
              3
            ],
            "details": "Create a validation function or service that runs before an edge is persisted. This function will perform a graph traversal (e.g., Depth-First Search) to detect cycles. It will also check if the target node already has an incoming edge (a parent). If validation fails, show an error message.",
            "status": "pending",
            "testStrategy": "Write tests for the validation logic. Attempt to create an edge that forms a simple cycle (A->B, B->A). Attempt to create a second incoming edge to a node that already has a parent. Verify both actions are blocked and return an error."
          },
          {
            "id": 5,
            "title": "Create EdgeTypeManager for Custom Type Management",
            "description": "Build a system that allows users to create, view, edit, and delete their own custom edge types.",
            "dependencies": [
              3
            ],
            "details": "Create a new interface, `EdgeTypeManager`, where users can manage their edge types. This requires API endpoints for CRUD operations on the `edge_types` table. The `EdgeCreationModal` must be updated to fetch and display these custom types along with the defaults.",
            "status": "pending",
            "testStrategy": "Test the full CRUD lifecycle of a custom edge type. Create a new type, verify it appears in the creation modal, use it to create an edge, then edit and delete the type, observing the expected behavior."
          },
          {
            "id": 6,
            "title": "Implement Edge Interaction Features (Hover, Delete, Notes)",
            "description": "Enhance created edges with user interactions, including hover effects for feedback, a mechanism for deletion, and a way to attach notes.",
            "dependencies": [
              1
            ],
            "details": "Update `components/Edge.tsx` to include `onMouseEnter` and `onMouseLeave` handlers for hover effects (e.g., change color/stroke-width). On hover, show a small 'delete' icon. Clicking the icon should trigger a confirmation and then deletion. A double-click on the edge should open a popover to add or edit a note.",
            "status": "pending",
            "testStrategy": "Visually test interactions. Hover over an edge to verify the effect. Click the delete icon and test both cancel and confirm actions. Double-click an edge, add a note, save it, and re-open to verify it was persisted."
          }
        ]
      },
      {
        "id": 8,
        "title": "Create brain dump management interface",
        "description": "Build side panel for brain dump switching, creation, and management",
        "details": "Create components/SidePanel.tsx with brain dump list, create/duplicate/delete actions. Implement smooth switching with viewport state restoration. Add inline name editing, confirmation modals for deletion. Create TopBar component with brain dump name, idea count, control panel dropdown. Add keyboard shortcuts (Ctrl+N, Ctrl+D, Ctrl+/).",
        "testStrategy": "Test brain dump CRUD operations, verify smooth switching with state restoration, test keyboard shortcuts, validate UI responsiveness",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create SidePanel Component with Brain Dump List",
            "description": "Build the foundational UI for the side panel, which will be responsible for displaying a list of all available brain dumps to the user. This is the first step in creating the management interface.",
            "dependencies": [],
            "details": "Create the file `components/SidePanel.tsx`. Implement a React component that fetches and renders a list of brain dumps from the global state or a mock data source. Focus on the visual layout, styling, and correct rendering of list items.",
            "status": "pending",
            "testStrategy": "Visually inspect the rendered component to ensure the list of brain dumps is displayed correctly. Verify that the component's styling matches the design specifications and is responsive."
          },
          {
            "id": 2,
            "title": "Implement Brain Dump CRUD Operations",
            "description": "Integrate Create, Read, Update, and Delete (CRUD) functionality for brain dumps. This includes adding UI controls and the logic to interact with the application's state and backend.",
            "dependencies": [
              1
            ],
            "details": "In the `SidePanel` component, add UI elements (e.g., buttons) for creating, duplicating, and deleting brain dumps. Implement the functions that handle these actions, including API calls. Add a confirmation modal for the delete action to prevent accidental data loss.",
            "status": "pending",
            "testStrategy": "Test the 'Create' action and verify a new brain dump appears. Test 'Duplicate' and confirm a copy is created. Test 'Delete' and ensure the item is removed after confirming in the modal."
          },
          {
            "id": 3,
            "title": "Implement Smooth Switching with Viewport State Restoration",
            "description": "Enable users to switch between different brain dumps by clicking on them in the side panel. The canvas's pan and zoom state for the selected brain dump should be restored upon switching.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add an onClick handler to the brain dump list items in the `SidePanel`. When an item is clicked, update the global state to set it as the active brain dump. The main canvas component should listen to this state change and re-render with the corresponding ideas and restore the saved viewport state (x, y, zoom) from the database.",
            "status": "pending",
            "testStrategy": "Set different pan/zoom levels for two separate brain dumps. Switch back and forth between them and verify that the canvas content and viewport position are correctly restored for each one."
          },
          {
            "id": 4,
            "title": "Create TopBar Component with Brain Dump Info and Controls",
            "description": "Build a `TopBar` component that displays contextual information about the currently active brain dump, such as its name and the number of ideas it contains.",
            "dependencies": [
              3
            ],
            "details": "Create a new component file `components/TopBar.tsx`. This component will subscribe to the application state to get the active brain dump's name and calculate the idea count. Also, include a dropdown menu for future controls like export or settings.",
            "status": "pending",
            "testStrategy": "Verify that the `TopBar` correctly displays the name of the active brain dump. Switch between dumps to see the name update. Add or remove ideas from a dump and check if the idea count updates accordingly."
          },
          {
            "id": 5,
            "title": "Add Inline Editing and Keyboard Shortcuts",
            "description": "Enhance user experience by adding quality-of-life features: inline name editing for brain dumps in the side panel and keyboard shortcuts for common management actions.",
            "dependencies": [
              2,
              4
            ],
            "details": "For inline editing, make the brain dump name in the list turn into a text input on double-click. On submit, trigger the update action. For shortcuts, implement global event listeners for `Ctrl+N` (new), `Ctrl+D` (duplicate), and `Ctrl+/` (toggle side panel visibility).",
            "status": "pending",
            "testStrategy": "Test inline editing by renaming a brain dump and verifying the change persists. Test each keyboard shortcut to confirm it triggers the correct action (e.g., `Ctrl+N` creates a new brain dump)."
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement API routes and data persistence",
        "description": "Create REST API endpoints for all CRUD operations with proper error handling",
        "details": "Create API routes in app/api/: brain-dumps (CRUD), ideas (CRUD), edges (CRUD), edge-types, attachments. Implement proper validation, error handling, database queries using pg library. Add background job processing for AI operations. Implement file upload to Supabase Storage. Add API middleware for request logging and rate limiting.",
        "testStrategy": "Test all API endpoints with proper data validation, verify file upload works, test error scenarios, validate database constraints",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Establish API Route Structure and Basic Configuration",
            "description": "Create the foundational directory structure for all API endpoints within the `app/api/` directory and set up initial configuration files for routing.",
            "dependencies": [],
            "details": "Create folders for `brain-dumps`, `ideas`, `edges`, `edge-types`, and `attachments` inside `app/api/`. Add placeholder `route.ts` files in each to ensure the structure is correct and ready for implementation.",
            "status": "pending",
            "testStrategy": "Verify that all specified directories and placeholder route files are created in the correct location. A simple `GET` request to a placeholder endpoint should return a success message."
          },
          {
            "id": 2,
            "title": "Implement CRUD Endpoints for Brain Dumps",
            "description": "Create and expose REST API endpoints for Create, Read, Update, and Delete operations on the `brain_dumps` table, including listing all brain dumps and fetching a single one.",
            "dependencies": [
              1
            ],
            "details": "Implement GET (list/single), POST, PUT/PATCH, and DELETE handlers in `app/api/brain-dumps/route.ts` and `app/api/brain-dumps/[id]/route.ts`. Use the 'pg' library to execute database queries against the `brain_dumps` table.",
            "status": "pending",
            "testStrategy": "Use Postman or a similar tool to test each endpoint (GET, POST, PUT, DELETE). Verify that data is correctly created, retrieved, updated, and deleted in the database."
          },
          {
            "id": 3,
            "title": "Implement CRUD Endpoints for Ideas",
            "description": "Create and expose REST API endpoints for Create, Read, Update, and Delete operations on the `ideas` table, ensuring they are associated with a specific brain dump.",
            "dependencies": [
              2
            ],
            "details": "Implement GET, POST, PUT/PATCH, and DELETE handlers within the API structure. Ensure all database queries for ideas are properly scoped to a `brain_dump_id` to maintain data integrity and separation.",
            "status": "pending",
            "testStrategy": "Test all CRUD endpoints for ideas. Verify that an idea can only be created or modified within the context of a valid `brain_dump_id`. Confirm that fetching ideas for a specific brain dump works correctly."
          },
          {
            "id": 4,
            "title": "Implement CRUD Endpoints for Edges and Edge Types",
            "description": "Create REST API endpoints for CRUD operations on `edges` and a read endpoint for `edge_types` to manage connections between ideas.",
            "dependencies": [
              3
            ],
            "details": "In `app/api/edges/route.ts`, implement GET, POST, and DELETE handlers. In `app/api/edge-types/route.ts`, implement a GET handler to list available types. Edge operations must validate that parent and child ideas exist.",
            "status": "pending",
            "testStrategy": "Test creating and deleting an edge between two existing ideas. Test retrieving all edges for a given brain dump. Verify the edge-types endpoint successfully returns the predefined list of types from the database."
          },
          {
            "id": 5,
            "title": "Implement File Upload to Supabase Storage for Attachments",
            "description": "Create an API endpoint to handle file uploads, store them in Supabase Storage, and create corresponding records in the `attachments` table linked to an idea.",
            "dependencies": [
              3
            ],
            "details": "Create `app/api/attachments/route.ts` to handle multipart/form-data requests. Use the Supabase client library for file uploads. On success, insert a new record into the `attachments` table with the file URL, metadata, and `idea_id`.",
            "status": "pending",
            "testStrategy": "Send a POST request with a file to the attachments endpoint. Verify the file appears in the Supabase Storage bucket and that a corresponding record is created in the `attachments` table with the correct URL and `idea_id`."
          },
          {
            "id": 6,
            "title": "Set Up Background Job Processing for AI Operations",
            "description": "Integrate a background job queue to handle asynchronous, long-running AI tasks like summarization and embedding generation without blocking API responses.",
            "dependencies": [
              3
            ],
            "details": "Configure a job queue (e.g., Inngest, Vercel Cron Jobs). When an idea is created/updated, enqueue a job with the idea's data. The job will call the OpenAI API for summarization/embeddings and update the database record upon completion.",
            "status": "pending",
            "testStrategy": "Create a new idea via its API endpoint and verify an immediate response. Monitor the job queue to confirm a task was enqueued. After a short delay, query the database to confirm the `summary` and `embeddings` fields have been populated."
          },
          {
            "id": 7,
            "title": "Add Robust Validation, Error Handling, and Middleware",
            "description": "Enhance all API endpoints with input validation using Zod, consistent error responses, and middleware for request logging and rate limiting.",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Use Zod schemas to validate request bodies for all POST and PUT/PATCH endpoints. Create a centralized error handler for consistent JSON error formatting. Implement Next.js middleware for logging requests and applying rate limiting with a tool like Upstash.",
            "status": "pending",
            "testStrategy": "Test endpoints with invalid data to verify 400-level errors are returned. Trigger the rate limiter by sending multiple requests quickly. Check server logs to confirm requests are being logged correctly."
          }
        ]
      },
      {
        "id": 10,
        "title": "Add advanced features and optimizations",
        "description": "Implement multi-select, theme system, keyboard shortcuts, and performance optimizations",
        "details": "Add selection rectangle for multi-select (drag on empty canvas), implement theme toggle (light/dark), add all keyboard shortcuts from PRD. Optimize rendering with React.memo, implement debouncing for API calls, add proper error boundaries. Create demo brain dump with sample data. Add accessibility features and responsive design considerations.",
        "testStrategy": "Test multi-select functionality, verify theme switching works, test all keyboard shortcuts, validate performance with 500+ ideas, test error boundaries",
        "priority": "medium",
        "dependencies": [
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Multi-Select with Selection Rectangle",
            "description": "Develop the functionality for users to select multiple 'idea' nodes by dragging a selection rectangle on the canvas. This includes visual feedback for the selection area and the selected items.",
            "dependencies": [],
            "details": "Implement a drag-to-select rectangle on the empty canvas. Manage the state of selected nodes. Apply a distinct visual style (e.g., border, background color) to all currently selected nodes.",
            "status": "pending",
            "testStrategy": "Test by dragging a selection rectangle over multiple nodes to confirm they become selected. Verify that shift-clicking adds/removes individual nodes from the selection. Ensure dragging on the canvas doesn't trigger other actions."
          },
          {
            "id": 2,
            "title": "Add Theme System with Light and Dark Modes",
            "description": "Create a theme system that allows users to toggle between a light and a dark mode. The user's preference should be saved and persist across sessions.",
            "dependencies": [],
            "details": "Utilize CSS variables for colors to facilitate easy theme switching. Create a theme context and provider. Add a UI toggle switch. Store the selected theme in localStorage to persist the choice.",
            "status": "pending",
            "testStrategy": "Toggle between light and dark themes and verify that all UI components update correctly. Reload the application to ensure the chosen theme persists. Check for any un-styled components."
          },
          {
            "id": 3,
            "title": "Implement All Keyboard Shortcuts from PRD",
            "description": "Integrate a comprehensive set of keyboard shortcuts for common actions as specified in the Product Requirements Document (PRD) to improve user efficiency.",
            "dependencies": [],
            "details": "Use a library like 'react-hotkeys-hook' to manage keyboard shortcuts. Implement shortcuts for creation, deletion, navigation, and other core actions. Ensure shortcuts are discoverable and don't conflict with browser defaults.",
            "status": "pending",
            "testStrategy": "Systematically test every keyboard shortcut defined in the PRD to confirm it performs the correct action. Test in major browsers (Chrome, Firefox, Safari) to identify and resolve any conflicts."
          },
          {
            "id": 4,
            "title": "Add Performance Optimizations (React.memo, Debouncing)",
            "description": "Optimize application performance by reducing unnecessary re-renders of components and debouncing frequent API calls to improve UI responsiveness, especially with large datasets.",
            "dependencies": [],
            "details": "Wrap static or memoizable components with React.memo. Implement a debounce utility for API calls triggered by frequent events like typing or dragging. Profile the application to identify performance bottlenecks.",
            "status": "pending",
            "testStrategy": "Use React Profiler to measure component render times before and after optimizations with a large number of nodes (500+). Verify in the network tab that API calls for position updates are debounced."
          },
          {
            "id": 5,
            "title": "Create Error Boundaries and Improve Accessibility",
            "description": "Implement React Error Boundaries to prevent UI crashes and enhance the application's accessibility (a11y) to support users with disabilities.",
            "dependencies": [],
            "details": "Wrap major sections of the application with Error Boundary components that display a fallback UI. Add ARIA roles and attributes to all interactive elements. Ensure logical focus order and full keyboard navigability.",
            "status": "pending",
            "testStrategy": "Simulate a render error in a child component to test that the Error Boundary catches it and displays the fallback UI. Use an accessibility audit tool like Axe to scan the application and fix reported issues."
          },
          {
            "id": 6,
            "title": "Build Demo Brain Dump with Sample Data",
            "description": "Create a pre-populated brain dump that serves as a demo or onboarding tool for new users, showcasing the application's key features and functionality.",
            "dependencies": [],
            "details": "Define a static JSON object representing a complete brain dump with various ideas, connections, and notes. This data should be loaded for new users or available to load on demand. It should demonstrate different node types and connections.",
            "status": "pending",
            "testStrategy": "Verify that the demo brain dump can be loaded successfully. Confirm that all sample ideas, edges, and their properties are rendered correctly and are fully interactive."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-29T10:43:46.463Z",
      "updated": "2025-10-29T10:43:46.463Z",
      "description": "Tasks for master context"
    }
  }
}